""""""from vnpy.app.cta_strategy import (    CtaTemplate,    StopOrder,    TickData,    BarData,    TradeData,    OrderData,    BarGenerator,    ArrayManager)from vnpy.trader.object import Offset, Direction, OrderType, Intervalfrom datetime import timefrom copy import copyclass BarEMaTrendActaulStrategy(CtaTemplate):    """"""    author = "BIlly Zhang"    init_pos = 0    init_entry_price = 0.0    Kxian = 1    HeYueJiaZhi = 100000    HeYueChengShu = 10.0    fixed_size = 1    QUICK_LENGTH = 5    SLOW_LENGTH = 20    CUT_LENGTH = 4    MARK_UP = 20    MARK_DOWN = 10    CLOSE_WINDOWS = 10    close_count_down = 0    entry_price = 0    high_close = 1000000    low_close = 0    cut_min = 0    OPEN_RATIO = 0.5    CLOSE_RATIO = 0    pricetick = 1    parameters = [        "init_pos",        "init_entry_price",        "fixed_size",        "HeYueJiaZhi",        "HeYueChengShu",        "Kxian",        "CLOSE_WINDOWS",        "QUICK_LENGTH",        "SLOW_LENGTH",        "CUT_LENGTH",        "OPEN_RATIO",        "MARK_DOWN",        "MARK_UP"    ]    variables = [        "entry_price",        "close_count_down",        "high_close",        "low_close"    ]    def __init__(self, cta_engine, strategy_name, vt_symbol, vt_local, setting):        """"""        super().__init__(cta_engine, strategy_name, vt_symbol, vt_local, setting)        if 360 > self.Kxian >= 240:            self.bg = BarGenerator(self.on_bar, 4, self.on_time_bar, Interval.HOUR)        elif 240 > self.Kxian >= 180:            self.bg = BarGenerator(self.on_bar, 3, self.on_time_bar, Interval.HOUR)        elif 180 > self.Kxian >= 60:            self.bg = BarGenerator(self.on_bar, 1, self.on_time_bar, Interval.HOUR)        elif self.Kxian >= 360:            self.bg = BarGenerator(self.on_bar, 1, self.on_time_bar, Interval.DAILY)        else:            self.bg = BarGenerator(self.on_bar, self.Kxian, self.on_time_bar, Interval.MINUTE)        self.close_indicator = 0        self.high_limit = 1000000        self.low_limit = 0        self.high_close = 0        self.low_close = 0        self.dou_high_close = 0        self.dou_low_close = 0        self.am = ArrayManager(60)        self.trend = 0        self.mark_up = 1        self.mark_down = 1        self.open_request = []        self.close_request = []        self.not_trading_time = False        if self.cut_min == 0:            self.start_timePM = time(hour=9, minute=10)            self.start_timeNI = time(hour=21, minute=10)        else:            self.start_timePM = time(hour=8, minute=59)            self.start_timeNI = time(hour=20, minute=59)        self.exit_timeAM = time(hour=14, minute=52)        self.exit_timeNI = time(hour=22, minute=52)        self.exit_open_timeAM = time(hour=14, minute=45)        self.exit_open_timeNI = time(hour=22, minute=45)    def on_init(self):        """        Callback when strategy is inited.        """        self.gap = self.pricetick * self.OPEN_RATIO        self.mark_up = self.pricetick * self.MARK_UP        self.mark_down = self.pricetick * self.MARK_DOWN        self.write_log("策略初始化")        self.load_bar(6)    def on_start(self):        """        Callback when strategy is started.        """        self.pos = self.init_pos        self.entry_price = self.init_entry_price        self.PosPrice = self.entry_price        self.write_log("策略启动")    def on_stop(self):        """        Callback when strategy is stopped.        """        self.write_log("策略停止")    def on_tick(self, tick: TickData):        """        Callback of new tick data update.        """        if self.pos > 0:            if self.close_indicator == 1 or tick.last_price < self.low_close:                self.cancel_all()                self.close_request = self.sell(tick.bid_price_1, self.pos, False)        elif self.pos < 0:            if self.close_indicator == -1 or tick.last_price > self.high_close:                self.cancel_all()                self.close_request = self.cover(tick.ask_price_1, abs(self.pos), False)        self.bg.update_tick(tick)    def cancel_ordrs(self, orders):        if self.open_request:            for vt_orderid in copy(orders):                self.cancel_order(vt_orderid)            self.open_request = None    def on_bar(self, bar: BarData):        """        Callback of new bar data update.        """        self.not_trading_time = self.check_not_trading_time(bar)        # for real deal        if self.not_trading_time:            if self.pos > 0:                self.close_indicator = 1            elif self.pos < 0:                self.close_indicator = -1            else:                self.cancel_all()        else:            if self.pos > 0:                if self.close_count_down <= 0:                    self.cancel_ordrs(self.open_request)                    self.close_request = self.sell(bar.close_price - self.pricetick, self.pos, False)                    self.close_indicator = 1                if not self.get_orderids():                    self.sell(self.high_close, self.pos, False)            elif self.pos < 0:                if self.close_count_down <= 0:                    self.cancel_ordrs(self.open_request)                    self.close_request = self.cover(bar.close_price + self.pricetick, abs(self.pos), False)                    self.close_indicator = -1                if not self.get_orderids():                    self.cover(self.low_close, abs(self.pos), False)        ## for backtest        # if self.not_trading_time:        #     if self.pos > 0:        #         self.cancel_ordrs(self.open_request)        #         self.close_request = self.sell(bar.close_price - self.pricetick, self.pos, False)        #     elif self.pos < 0:        #         self.cancel_ordrs(self.open_request)        #         self.close_request = self.cover(bar.close_price + self.pricetick, abs(self.pos), False)        #     else:        #         self.cancel_ordrs(self.open_request)        # else:        #     if self.pos > 0:        #         if self.close_count_down <= 0:        #             self.cancel_ordrs(self.open_request)        #             self.close_request = self.sell(bar.close_price - self.pricetick, self.pos, False)        #         elif bar.low_price < self.low_close:        #             self.cancel_ordrs(self.open_request)        #             self.sell(bar.close_price - self.pricetick, self.pos, False)        #     elif self.pos < 0:        #         if self.close_count_down <= 0:        #             # self.close_indicator = -1        #             self.cancel_ordrs(self.open_request)        #             self.close_request = self.cover(bar.close_price + self.pricetick, abs(self.pos), False)        #         elif bar.high_price > self.high_close:        #             self.cancel_ordrs(self.open_request)        #             self.close_request = self.cover(bar.close_price + self.pricetick, abs(self.pos), False)        self.close_count_down -= 1        self.bg.update_bar(bar)    def check_inc_or_dec(self, a, b, gap):        c = [round(i - j,2) for i, j in zip(a, b)]        is_increasing = True        is_decreasing = True        for i in range(1, len(c)):            if c[i] <= c[i - 1] or c[i] < gap:                is_increasing = False            if c[i] >= c[i - 1] or c[i] > -gap:                is_decreasing = False        if is_increasing and c[0] < gap:            return 1        elif is_decreasing and c[0] > -gap:            return -1        else:            return 0    def on_time_bar(self, bar: BarData):        am = self.am        am.update_bar(bar)        if not am.inited:            return        ema_quick = am.ema(self.QUICK_LENGTH, True)[-self.CUT_LENGTH:]        ema_slow = am.ema(self.SLOW_LENGTH, True)[-self.CUT_LENGTH:]        self.trend = self.check_inc_or_dec(ema_quick, ema_slow, self.gap)        if self.trading:            self.write_log(                f"pos is {self.pos}, emaquick is {ema_quick}, emaslow is P{ema_slow}, trend is {self.trend}")        if not self.not_trading_time:            if self.pos == 0:                self.cancel_all()                if self.trend == 1 and am.close[-1]> am.close[-2]:                        self.buy(price=bar.close_price, volume=self.fixed_size, stop=False)                elif self.trend == -1 and am.close[-1] < am.close[-2]:                        self.short(price=bar.close_price, volume=self.fixed_size, stop=False)        self.put_event()    def on_order(self, order: OrderData):        """        Callback of new order data update.        """        pass    def on_trade(self, trade: TradeData):        """        Callback of new trade data update.        """        if trade.offset == Offset.OPEN:            self.close_indicator = 0            self.entry_price = trade.price            self.close_count_down = self.CLOSE_WINDOWS            if trade.direction == Direction.LONG:                self.high_close =trade.price + self.mark_up                self.open_request = self.sell(self.high_close, trade.volume, False)                self.low_close = trade.price - self.mark_down                # self.dou_low_close = trade.price - 2*self.mark_down            else:                self.high_close = trade.price + self.mark_down                # self.dou_high_close =trade.price + 2*self.mark_down                self.low_close = trade.price - self.mark_up                self.open_request = self.cover(self.low_close, trade.volume, False)        if trade.offset == Offset.CLOSE and self.pos == 0:            self.close_indicator = 0    def on_stop_order(self, stop_order: StopOrder):        """        :param stop_order:        :return:        """        pass